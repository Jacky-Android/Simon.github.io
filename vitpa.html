<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/55181594?v=4">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>ViT论文&nbsp;|&nbsp;Simon’s Blogs</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="ViT论文">
  
  
    <meta property="og:image" content="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🍧&lt;/text&gt;&lt;/svg&gt;">
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="https://avatars.githubusercontent.com/u/55181594?v=4"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="road.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🤑&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>2024年深度学习学习路线</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>About me</span>
        </div>
      </a>
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="12.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🤏&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>训练神经网络的技巧</span>
        </div>
      </a>
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
      <div class="Header__Icon">
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🍧&lt;/text&gt;&lt;/svg&gt;"></span>
      </div>
    
    <h1 class="Header__Title">ViT论文</h1>
    
  </header>
  <article id="https://www.notion.so/7e859a2e83a34f7fb0689dfb66136867" class="PageRoot"><ul id="https://www.notion.so/3dfe7b789c6a45f3b45715a681358370" class="ColorfulBlock ColorfulBlock--ColorGray TableOfContents"><li class="TableOfContents__Item"><a href="#https://www.notion.so/3f5ff410cfb840408ecbc00d8e51246f"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">架构细节</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/e761bd81687f402d975bea8ca6862003"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">Abstract</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b51f262d94854f1799303b7a83e278c5"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">1 Introduction</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/f21923c8ef9f46f89ae7801dd3165f7b"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">2 Related Work</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/30342a7824364ec0939b2fe8fb0cb0cd"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">3 Method</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/191caed17424405a8292d026226ba0af"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">3.1 VISION T RANSFORMER (V I T)</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/28b3586c3a8641a09f61517d0acdf507"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">Embedding 层</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/9d5ab333aec84abc9f66814502ce54cd"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">Transformer Encoder</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/336d83b2a84440df8513ad2d617e2c72"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">MLP Head</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/940aae8535bd4cb6b18fcc8be6a1aaa0"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">3.2 F INE - TUNING AND H IGHER R ESOLUTION</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/189540d277cc4fb48244f92cc5598398"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">4 Experiments</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/fb87f1d17f4a4ed1a9914a1a45cd07cf"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">5 Conclusion</span></span></div></a></li></ul><div id="https://www.notion.so/ef673e9577b648a89ba1a2e9b7175bfd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Vision Transformer（ViT）是一种基于Transformer的图像分类模型，颠覆了传统卷积神经网络（CNN）的架构。以下是Vision Transformer分类模型的一些关键细节：</span></span></p></div><h3 id="https://www.notion.so/3f5ff410cfb840408ecbc00d8e51246f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/3f5ff410cfb840408ecbc00d8e51246f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">架构细节</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/3168214a4dfe4bbbac4acaf32b9eace3" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">输入表示（Input Representation）</strong></span><span class="SemanticString">：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/78e7b5e189a2468db74de5d021813a53" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">输入图像被切割成固定大小的图像块（patches），例如16x16像素。</span></span></li><li id="https://www.notion.so/41c941bf922b458cad52b5987068223e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">将这些图像块展平（flatten），形成一维的向量，每个向量表示一个图像块。</span></span></li><li id="https://www.notion.so/0d7087f232da4f289d461291d4244ae9" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">使用线性变换（linear projection）将每个图像块向量映射到固定维度的嵌入空间。</span></span></li></ul></li><li id="https://www.notion.so/adf011c9471940ba9b5a51dea396c444" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">位置编码（Position Embeddings）</strong></span><span class="SemanticString">：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/58d4229e6e934ab9b171b9419c628065" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">类似于Transformer在自然语言处理中的位置编码，ViT也为每个图像块添加一个位置编码，以保留位置信息。</span></span></li><li id="https://www.notion.so/518328100dc94905b74b0285d1cde6d1" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">这些位置编码与图像块嵌入相加，形成最终的输入表示。</span></span></li></ul></li><li id="https://www.notion.so/233c0dfea9ce468c821a8084707cca67" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Transformer编码器（Transformer Encoder）</strong></span><span class="SemanticString">：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/c4573d197ba84d99ade19a4b31faccaf" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">多层Transformer编码器应用于输入表示，每层包含多头自注意力机制（Multi-Head Self-Attention）和前馈神经网络（Feed-Forward Neural Network）。</span></span></li><li id="https://www.notion.so/3d8b5b6cdca742c988decec53b205f6d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">通过残差连接（Residual Connections）和层归一化（Layer Normalization）稳定训练过程。</span></span></li></ul></li><li id="https://www.notion.so/768bc10dc459496ca8311bc1f2509d47" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">分类头（Classification Head）</strong></span><span class="SemanticString">：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/303e996dcb734609bbee90e169ffc546" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">使用一个特殊的分类令牌（[CLS] token），它的初始状态是一个可学习的参数，经过Transformer层后用于分类任务。</span></span></li><li id="https://www.notion.so/5fd4b1c774c74d6dab354488701818e4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">最后一个Transformer编码器层的输出[CLS] token通过一个全连接层（Fully Connected Layer）进行分类。</span></span></li></ul></li></ol><h2 id="https://www.notion.so/e761bd81687f402d975bea8ca6862003" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/e761bd81687f402d975bea8ca6862003"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Abstract</span></span></h2><div id="https://www.notion.so/3e9dcdfe66b0417b83f61b0de47fd5e9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">其实摘要就说了一件事，在视觉领域，我们就利用 transformer 取得的效果比你 CNN 要好。</span></span></p></div><blockquote id="https://www.notion.so/d82a781e65d8412082d6633e0ea285c6" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">虽然 Transformer 架构已成为自然语言处理任务的事实标准，但其在计算机视觉中的应用仍然有限。在视觉上，注意力要么与卷积网络结合使用，要么用于替换卷积网络的某些组件，同时保持其整体结构不变。我们表明，这种对 CNN 的依赖是不必要的，直接应用于图像块序列的纯变换器可以在图像分类任务上表现得非常好。当对大量数据进行预训练并转移到多个中型或小型图像识别基准（ImageNet、CIFAR-100、VTAB 等）时，与最先进的卷积神经网络相比，Vision Transformer (ViT) 取得了出色的结果，同时需要更少的计算资源来训练。</span></span></blockquote><div id="https://www.notion.so/b23095c910be4f33b11669b6be2d3b46" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">⚠️注意：当你看到论文里说IN是中小型数据集的时候就注意了，对Google那帮人来说是，咱们就不要主观代入了，另外这里更少的训练资源是指2500天TPUv3的训练。</span></span></p></div><h2 id="https://www.notion.so/b51f262d94854f1799303b7a83e278c5" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/b51f262d94854f1799303b7a83e278c5"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">1 Introduction</span></span></h2><div id="https://www.notion.so/f0318bc6b7634837a334a9b4ec29afb3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">引言主要有这几个点：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/7fd9dc1020164655922b2b0a8cff3da6" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">Transformer 已经在 NLP 领域取得大规模的应用，具有很好的计算效率和可扩展性，并且随着模型增大，性能没有饱和（这也就是为什么想把 transformer 引入到视觉领域的一个原因）</span></span></li><li id="https://www.notion.so/7a11b6a5b5e6486bba5c46d6dbbb3242" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">作者尽可能不对 transformer 进行修改，这样才可以证明不是因为引入对视觉友好的一些方法，而是 transformer 本身就可以胜任视觉任务并取得很好的结果。</span></span></li><li id="https://www.notion.so/ef1dd1ba14564cfd8dba264346af3922" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">在中小型数据集上训练确实不如 ResNet 等网络效果更好，因为传统的 CNN 有两个先验知识（归纳偏执）：translation equivariance 无论先做卷积还是先做平移，效果是一样的；locality 指的是图片相邻像素具有一定关系。如果放在更大的数据集里面进行训练，那就不需要这些归纳偏执了。所以在更大规模的数据集上进行训练，取得的效果比 CNN 的要好。</span></span></li></ol><blockquote id="https://www.notion.so/9b8a6ea380174f1d9d0a98f7daaa6b95" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">基于自注意力的架构，尤其是 Transformers ，已成为自然语言处理 (NLP) 的首选模型。主要的方法是在大型文本语料库上进行预训练，然后在较小的特定任务数据集上进行微调。由于 Transformers 的计算效率和可扩展性，训练具有超过 100B 参数的前所未有的模型成为可能。随着模型和数据集的增长，仍然没有饱和性能的迹象。</span></span><div id="https://www.notion.so/f03f55de6d7343839c4dbab31caa9f33" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">然而，在计算机视觉中，卷积架构仍然占主导地位。受 NLP 成功的启发，很多工作尝试将类似 CNN 的架构与自注意相结合，其中一些完全取代了卷积。有些模型虽然在理论上是有效的，但由于使用了专门的注意力模式，尚未在现代硬件加速器上有效地扩展。因此，在大规模图像识别中，经典的 ResNet架构仍然是最先进的。</span></span></p></div><div id="https://www.notion.so/d3350dd592db4403888554b2e99cfe50" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">受 NLP 中 Transformer 可扩展性的启发，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">我们尝试将标准 Transformer 直接应用于图像，尽可能少地进行修改</strong></span><span class="SemanticString">。为此，我们将图像拆分为块，并提供这些块的线性嵌入序列作为 Transformer 的输入。图像块的处理方式与 NLP 应用程序中的标记（单词）相同。我们以监督方式训练模型进行图像分。</span></span></p></div><div id="https://www.notion.so/88e4179b8135417aba2699bc8d1c17eb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当在没有强正则化的 ImageNet 等中型数据集上进行训练时，这些模型产生的准确度比同等大小的 ResNet 低几个百分点。这种看似令人沮丧的结果可能是意料之中的：Transformers 缺乏 CNN 固有的一些归纳偏差，例如 translation equivariance 平移等效性和 locality 局部性，因此在对数据量不足进行训练时不能很好地泛化。</span></span></p></div><div id="https://www.notion.so/1ea3cdbc7fe544ceada9c4cd16eeed8d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是，如果模型在更大的数据集（14M-300M 图像）上训练，情况就会发生变化。我们发现大规模训练胜过归纳偏差。我们的 Vision Transformer (ViT) 在足够的规模进行预训练并转移到具有较少数据点的任务时获得了出色的结果。当在 ImageNet-21k 数据集或 JFT-300M 数据集上进行预训练时，ViT 在多个图像识别基准上接近或超过了最先进的水平。特别是，最好的模型在 ImageNet 上达到 88.55%，在 ImageNet-ReaL 上达到 90.72%，在 CIFAR-100 上达到 94.55%，在 19 个任务的 VTAB 上达到 77.63%。</span></span></p></div></blockquote><h2 id="https://www.notion.so/f21923c8ef9f46f89ae7801dd3165f7b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/f21923c8ef9f46f89ae7801dd3165f7b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">2 Related Work</span></span></h2><div id="https://www.notion.so/ce89f969fe594e26b4976e0fe0f41225" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果直接把一张图片拉成一个向量，那么对于 rransformer 来说，序列长度太长，计算复杂度过高。所以 Cordonnier 等人的模型。，它从输入图像中提取大小为 2 × 2 的 patch。这里其实已经使用的是 transformer 了，但是奈何Google 更有钱啊，直接弄个 16 x 16 的patch，可以处理224的图像了，并且在大型数据集上取得非常好的效果。</span></span></p></div><blockquote id="https://www.notion.so/a55f6739a0aa49ddb9275629164cdbbe" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">Transformer 由 Vaswani 等人提出，用于机器翻译，并已成为许多 NLP 任务中最先进的方法。基于大型 Transformer 的模型通常在大型语料库上进行预训练，然后针对手头的任务进行微调：BERT 使用去噪自监督预训练任务，而 GPT 工作线使用语言建模作为其预训练任务。</span></span><div id="https://www.notion.so/1e752be316d94401a7340a89a7d37454" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">将自注意力简单地应用于图像需要每个像素都关注其他每个像素。由于像素数量的二次成本，这不能扩展到实际的输入大小。因此，为了在图像处理的上下文中应用 Transformer，过去曾尝试过几种近似方法。Parmar 等人仅在每个查询像素的局部邻域中应用自注意，而不是全局。这种局部多头点积自注意力块可以完全替代卷积。在另一项工作中，Sparse Transformers (Child et al., 2019) 对全局自注意力采用可扩展的近似值，以便适用于图像。扩展注意力的另一种方法是将其应用于不同大小的块，在极端情况下仅沿单个轴。许多这些专门的注意力架构在计算机视觉任务上展示了有希望的结果，但需要在硬件加速器上并且十分复杂。</span></span></p></div><div id="https://www.notion.so/40bc4be8e80e454e9acc2d6307a2c054" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">与我们最相关的是 Cordonnier 等人的模型。，它从输入图像中提取大小为 2 × 2 的 patch ，并在顶部应用完全自注意力。该模型与 ViT 非常相似，但我们的工作进一步证明了大规模的预训练使 vanilla Transformer 可以与（甚至优于）最先进的 CNN 竞争。此外，Cordonnier 等人使用 2 × 2 像素的小块大小，这使得该模型仅适用于小分辨率图像，而我们也处理中等分辨率图像。</span></span></p></div><div id="https://www.notion.so/8abda6b019c3456ead218d014149bda4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">将卷积神经网络 (CNN) 与自注意形式相结合也引起了很多兴趣，例如通过为图像分类增加特征图或通过使用自注意进一步处理 CNN 的输出，例如用于对象检测（Hu et al., 2018; Carion et al., 2020）、视频处理（Wang et al., 2018; Sun et al., 2019）、图像分类（Wu et al., 2020）、无监督对象发现（Locatello 等人，2020）或统一的文本视觉任务（Chen 等人，2020c；Lu 等人，2019；Li 等人，2019）。</span></span></p></div><div id="https://www.notion.so/0b750504a4d740be976a669c2c6b8c3a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另一个最近的相关模型是图像 GPT (iGPT) (Chen et al., 2020a)，它在降低图像分辨率和色彩空间后将 Transformers 应用于图像像素。该模型作为生成模型以无监督方式进行训练，然后可以对生成的表示进行微调或线性探测以提高分类性能，在 ImageNet 上达到 72% 的最大准确度。</span></span></p></div><div id="https://www.notion.so/f1db99a6e7a443058afcbcb45215bfac" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们的工作增加了越来越多的论文，这些论文探索了比标准 ImageNet 数据集更大规模的图像识别。使用额外的数据源可以在标准基准上实现最先进的结果（Mahajan 等人，2018；Touvron 等人，2019；Xie 等人，2020）。此外，Sun 等人。 (2017) 研究 CNN 性能如何随数据集大小扩展，以及 Kolesnikov 等人。 （2020）； Djolonga 等人。 (2020) 对 ImageNet-21k 和 JFT-300M 等大规模数据集的 CNN 迁移学习进行了实证探索。我们也关注后两个数据集，但训练 Transformer 而不是之前工作中使用的基于 ResNet 的模型。</span></span></p></div></blockquote><div id="https://www.notion.so/9363cb926523476c8490ca34a2790e2c" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/30342a7824364ec0939b2fe8fb0cb0cd" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/30342a7824364ec0939b2fe8fb0cb0cd"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">3 Method</span></span></h2><blockquote id="https://www.notion.so/fa4e0ed3c43f400fa62b66ce0c4be899" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">在模型设计中，我们尽可能地遵循原始的 Transformer (Vaswani et al., 2017)。这种有意的简单设置的优点是可扩展的 NLP Transformer 架构及其高效的实现几乎可以开箱即用。</span></span></blockquote><h3 id="https://www.notion.so/191caed17424405a8292d026226ba0af" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/191caed17424405a8292d026226ba0af"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">3.1 VISION T RANSFORMER (V I T)</span></span></h3><blockquote id="https://www.notion.so/08c1557343f14c1fb70e8ebb52c61315" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">该模型的概述如图 1 所示。标准 Transformer 接收一维 token 嵌入序列作为输入。为了处理 2D 图像，我们将图像</span></span><div id="https://www.notion.so/973b374517a443858662830c01fa2774" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/0fc88a8e492c4cfab89b5ed2447ed2c9" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/acf7fc9da69342aba292bf8b69e3d1bc" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/db9c282c5b91454881c2b7e40e9dc85b" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/e79cc301f4a64023a2991cd6c6145fee" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/0e69c3a780b14b4a8bad3741d0f682bc" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/a71f1ed0515448f3a835800219e1c836" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/0e53920469f64aa48521430fe695b0b4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Position embedding 被添加到 patch embedding 中以保留位置信息。我们使用标准的可学习 1D 位置嵌入，因为我们没有观察到使用更高级的 2D 感知位置嵌入（附录 D.4）可以显着提高性能。生成的嵌入向量序列用作编码器的输入。</span></span></p></div><div id="https://www.notion.so/e553889a780c4203983297d983d3680c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Transformer 编码器由多头自注意力和 MLP 块的交替层组成。在每个块之前应用</span></span></p></div><div id="https://www.notion.so/8fcf3fa3c5b6446abe7892ffaa2693cf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Layernorm (LN)，在每个块之后应用残差连接 。</span></span></p></div><div id="https://www.notion.so/a66a8ea7aecd471ca96e7a17eb911413" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/5f0027e0117e4258a7308e14d098c412" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Inductive bias.</strong></span><span class="SemanticString"> 我们注意到，与 CNN 相比，Vision Transformer 的图像特定归纳偏差要小得多。在 CNN 中，局部性、二维邻域结构和平移等效性被整个模型的每一层中都存在。在 ViT 中，只有 MLP 层存在局部性的和平移等变性的，而自注意力层是全局的。二维邻域结构的使用非常谨慎：在模型开始时，通过将图像切割成块，并在微调时调整不同分辨率图像的位置嵌入（如下所述）。除此之外，初始化时的位置嵌入不携带有关补丁的 2D 位置的信息，并且必须从头开始学习补丁之间的所有空间关系。</span></span></p></div><div id="https://www.notion.so/844b4cf7c79343ff8edc0e7addb0e582" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Hybrid Architecture.</strong></span><span class="SemanticString"> 作为原始图像块的替代方案，输入序列可以由 CNN 的特征图形成（LeCun 等人，1989）。在这个混合模型中，patch 嵌入投影 E（等式 1）应用于从 CNN 特征图中提取的 patch。作为一种特殊情况，patch 可以具有 1x1 的空间大小，这意味着输入序列是通过简单地将特征图的空间维度展平并投影到 Transformer 维度来获得的。如上所述添加分类输入嵌入和位置嵌入。</span></span></p></div></blockquote><div id="https://www.notion.so/7792263eb05b4470b61d84ebb872a628" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这一部分就一下把 ViT 说的很明白了，它的结构就是新的 Embedding 层 + transformer 中的 Encoder 层 + MLP 层，是不是很简单！</span></span></p></div><div id="https://www.notion.so/a3291e4d0e404eb1a3020e15a35e8166" class="Divider"></div><h3 id="https://www.notion.so/28b3586c3a8641a09f61517d0acdf507" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/28b3586c3a8641a09f61517d0acdf507"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Embedding 层</span></span></h3><div id="https://www.notion.so/b125c3921bd149fb91296dfb2a5d92c0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">原文把 embedding 层的过程讲的很清楚了，这里，我用 ViT-B/16 （ViT\_base\_patch16）举例说明。首先以 224 x 224 输入，把图像分割成 16 x 16 的 patch ，那么就存在</span></span></p></div><div id="https://www.notion.so/b9f853622f0f4857a158aa0d978a4fef" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/bd6d042cc5fd4339aa483db7cb2da4e2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">个 patch。然后讲这 196 个patch 映射到</span></span></p></div><div id="https://www.notion.so/bc9784bf202348bba88088b1934361ab" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/25ae33766b39445a9f54b27ccf0f0bd6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">的向量里。每个 patch 的 shape 是 \[16, 16, 3\]（长和宽为 16 ，通道数为 3）。代码中这一步实现是通过一个卷积实现的</span></span></p></div><pre id="https://www.notion.so/4b8090ea09ef49cb98fdfdd01b556826" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>Conv2d(in_c, embed_dim, kernel_size=patch_size, stride=patch_size)
</span></span></span></code></pre><div id="https://www.notion.so/d1cbbffa7f994d0d8da8a9939b678b87" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">卷积核大小为 16 ，步长为16，输入维度是 3，输出维度是 768 。妙啊！！</span></span></p></div><div id="https://www.notion.so/233893fb67d14988b3ff8f91c10ac138" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这样图片就由原来的 \[224, 224, 3\] 变成了 \[14, 14, 768\] ，经过 Flatten 就得到 \[196, 768\]。</span></span></p></div><div id="https://www.notion.so/739b9b0d8a41420dac1183faebe5505f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">添加一个专门用于分类的 token 。文中提到这里添加方式与 BERT 类似，添加一个可以通过学习得到的 \[class\] token，为了保持维度一致，\[class\] token的维度为 \[1, 768\] 。通过Concat操作，\[196, 768\]  与 \[1, 768\] 拼接得到 \[197, 768\]  。</span></span></p></div><div id="https://www.notion.so/3b34c64aa7d646df9f1be5de97e0b4ec" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">随后就是对于这些 token 添加位置信息，也就是 position embedding。这里和 transformer 一致，都是可训练的参数，因为要</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">加</strong></span><span class="SemanticString">到所有 token 上，所以维度也是 \[197, 768\]  。</span></span></p></div><div id="https://www.notion.so/2a4b0f4596b446d49a0b37a3ee985b31" class="Divider"></div><h3 id="https://www.notion.so/9d5ab333aec84abc9f66814502ce54cd" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/9d5ab333aec84abc9f66814502ce54cd"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Transformer Encoder</span></span></h3><div id="https://www.notion.so/c37d47b19b584dc48ef89be3d4865836" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这一部分就和 transformer 中的 encoder 一摸一样了，可以看之前写的详解</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://blog.csdn.net/like_jmo/article/details/125992409?spm=1001.2014.3001.5501">transformer详解</a></span></span></p></div><div id="https://www.notion.so/0db48dcf8d234b06956c88081a7a0cc4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">简单来说就是 N x Blocks(Multi-Head Attention + MLP)</span></span></p></div><div id="https://www.notion.so/08d02665e2ee478abe33dad3e3d6809a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 ViT-B/16 中，输入是 \[197, 768\] 输出也是 \[197, 768\] 。</span></span></p></div><div id="https://www.notion.so/d2309bb94722456a98b6341b622d999f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">然后就是接一个 MLP Head 进行最后的分类结果的输出。</span></span></p></div><div id="https://www.notion.so/7dc95195d38d4f18afa3bb763312a9a1" class="Divider"></div><h3 id="https://www.notion.so/336d83b2a84440df8513ad2d617e2c72" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/336d83b2a84440df8513ad2d617e2c72"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">MLP Head</span></span></h3><div id="https://www.notion.so/d1291164e3604f5dab8e6db63b973829" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">其实这里更简单了，和 transformer 唯一不同的是，transformer 利用了所有的输出 token ，但是 ViT 只是进行分类，在这里只需要 \[class\] token 对应位置进行输出就可以。</span></span></p></div><div id="https://www.notion.so/65100a2e93b7421c9844e16a418e0672" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">输出方法也很简单就是一个全联接神经网络！就是这么简单！</span></span></p></div><div id="https://www.notion.so/2c47ff65f3994fd782599726f47cdb95" class="Divider"></div><h3 id="https://www.notion.so/940aae8535bd4cb6b18fcc8be6a1aaa0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/940aae8535bd4cb6b18fcc8be6a1aaa0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">3.2 F INE - TUNING AND H IGHER R ESOLUTION</span></span></h3><blockquote id="https://www.notion.so/dfc9152b9d954708ab41b10b7d201ebf" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">通常，我们在大型数据集上预训练 ViT，并对（较小的）下游任务进行微调。为此，我们移除预训练的预测头并附加一个零初始化的 D × K 前馈层，其中 K 是下游类的数量。与预训练相比，以更高的分辨率进行微调通常是有益的（Touvron 等人，2019；Kolesnikov 等人，2020）。当提供更高分辨率的图像时，我们保持补丁大小相同，从而产生更大的有效序列长度。 Vision Transformer 可以处理任意序列长度（直至内存限制），但会导致预训练的位置信息不再有意义。因此，我们根据它们在原始图像中的位置对预训练的位置嵌入进行 2D 插值。请注意，这种分辨率调整和补丁提取是将有关图像 2D 结构的归纳偏差手动注入视觉转换器的唯一点。</span></span></blockquote><h2 id="https://www.notion.so/189540d277cc4fb48244f92cc5598398" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/189540d277cc4fb48244f92cc5598398"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">4 Experiments</span></span></h2><div id="https://www.notion.so/1d091885bd52470c843800a7a48a5614" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/0bb9601f20ad4fd59a218c956af7994c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">可以看到这个参数量对我们而言还是非常夸张的，所以在训练自己的 transformer 时，还是要使用他们的预训练好的权重文件。</span></span></p></div><div id="https://www.notion.so/760709f06b9345a9b7c0f47e3b1893cd" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/1376974450ff43619f7f3cb6f032ded9" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/b516af2d4c184a7ea7ddbb7ed68de326" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h2 id="https://www.notion.so/fb87f1d17f4a4ed1a9914a1a45cd07cf" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/fb87f1d17f4a4ed1a9914a1a45cd07cf"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">5 Conclusion</span></span></h2><blockquote id="https://www.notion.so/86aaece1c2ac4d8d90bf8a7df7aee57a" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">我们已经探索了 transformer 在图像识别中的直接应用。与在计算机视觉中使用自注意力的先前工作不同，除了初始 patch 提取步骤之外，我们不会将特定于图像的归纳偏差引入架构中。相反，我们将图像解释为一系列 patch，并通过使用 NLP 中的标准 Transformer 编码器对其进行处理。这种简单但可扩展的策略在与大型数据集的预训练相结合时效果出奇地好。因此，Vision Transformer 在许多图像分类数据集上匹配或超过了最先进的技术，同时预训练成本相对较低。</span></span><div id="https://www.notion.so/0f601c50785a4efa8f7f4562953eeb4c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">虽然这些初步结果令人鼓舞，但仍然存在许多挑战。一种是将 ViT 应用于其他计算机视觉任务，例如检测和分割。我们的结果，再加上 Carion 等人的结果，表明这种方法的承诺。另一个挑战是继续探索自我监督的预训练方法。我们最初的实验表明 自监督预训练的改进，但自监督和大规模监督预训练之间仍有很大差距。最后，进一步扩展 ViT 可能会提高性能。</span></span></p></div></blockquote></article>
  <footer class="Footer">
  <div>&copy; Simon’s Blogs 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>